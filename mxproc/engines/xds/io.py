import os
import shutil
from pathlib import Path
from dataclasses import dataclass, field
from typing import Union, Literal, Tuple, Sequence

import numpy

from mxproc.experiment import Lattice, Experiment

XDSJob = Literal["XYCORR", "INIT", "COLSPOT", "IDXREF",  "DEFPIX", "INTEGRATE", "CORRECT", "ALL"]
XDSRefinement = Literal["CELL", "BEAM", "ORIENTATION", "AXIS",  "DISTANCE", "POSITION", "SEGMENT", "ALL"]


@dataclass
class XDSParameters:
    data_range: Tuple[int, int]
    spot_range: Sequence[Tuple[int, int]]
    format: str = ""
    skip_range: Sequence[Tuple[int, int]] = ()
    lattice: Lattice = field(default_factory=Lattice)
    reindex: Sequence[int] | None = None
    reference: Path | None = None
    plugin: str | None = None
    min_spot_size: int | None = None
    min_spot_separation: int | None = None
    cluster_radius: int or None = None
    strong_sigma: int or None = 4
    anomalous: bool = False
    strict_absorption: bool = False
    fixed_scale_factors: bool = False
    max_profile_error: Tuple[float, float] | None = None
    message: str = ""
    refine_index: Sequence[XDSRefinement] = ('CELL', 'BEAM', 'ORIENTATION', 'AXIS')
    refine_integrate: Sequence[XDSRefinement] = ('POSITION', 'BEAM', 'ORIENTATION')


def create_input_file(jobs: Sequence[XDSJob], experiment: Experiment, parameters: XDSParameters):
    """
    Create an XDS.INP input file

    :param jobs: a sequence of XDS Job keys
    :param experiment: Experiment instance
    :param parameters: The parameters to be used when creating the file.
    """

    detector_name = experiment.detector.upper()
    parameters.format = experiment.format
    if 'ADSC' in detector_name:
        detector_type = 'ADSC'
    elif 'RAYONIX' in detector_name:
        detector_type = 'CCDCHESS'
    elif 'RAXIS' in detector_name:
        detector_type = 'RAXIS'
    elif 'PILATUS' in detector_name:
        detector_type = 'PILATUS'
        parameters.min_spot_size = 2
    elif 'EIGER' in detector_name:
        detector_type = 'EIGER'
        parameters.min_spot_size = 3
        parameters.min_spot_separation = 4
        parameters.cluster_radius = parameters.min_spot_separation//2
        if experiment.format == "NXmx":
            parameters.format = "GENERIC"
            parameters.plugin = shutil.which('durin-plugin.so')
        elif parameters.format == "HDF5":
            parameters.format = "GENERIC"
            parameters.plugin = shutil.which('dectris-neggia.so')
    else:
        detector_type = 'CCDCHESS'

    two_theta_radians = numpy.radians(experiment.two_theta)
    detector_y_axis = (0.0, numpy.cos(two_theta_radians), -1 * numpy.sin(two_theta_radians))
    jobs_flag = " ".join(jobs)
    friedel_flag = {True: 'FALSE', False: 'TRUE'}[parameters.anomalous]
    template_path = experiment.directory / experiment.template

    job_text = (
        f"!- XDS.INP ----------- Generated by MX Process\n"
        f"JOB=   {jobs_flag}\n"
    )
    dataset_text = (
        f"!------------------- Dataset parameters\n"
        f"X-RAY_WAVELENGTH=  {experiment.wavelength:7.5f}\n"
        f"DETECTOR_DISTANCE= {experiment.distance:5.1f}\n"
        f"STARTING_ANGLE=    {experiment.start_angle:5.1f}\n"
        f"STARTING_FRAME=    {parameters.data_range[0]}\n"
        f"OSCILLATION_RANGE= {experiment.delta_angle:4.2f}\n"
        f"FRIEDEL'S_LAW= {friedel_flag}\n"
        f"NAME_TEMPLATE_OF_DATA_FRAMES={template_path} {parameters.format}\n"
        f"DATA_RANGE=    {parameters.data_range[0]} {parameters.data_range[1]}\n"
    )
    for start, end in parameters.spot_range:
        dataset_text += f"SPOT_RANGE=    {start} {end}\n"

    for start, end in parameters.skip_range:
        dataset_text += f"EXCLUDE_DATA_RANGE=    {start} {end}\n"

    # Allow injecting an external library for reading dataset files
    if parameters.plugin is not None:
        dataset_text += f'LIB= {parameters.plugin}\n'

    if parameters.lattice.spacegroup > 0:
        # space group and cell parameters
        dataset_text += (
            f"SPACE_GROUP_NUMBER=  {parameters.lattice.spacegroup}\n"
            f"UNIT_CELL_CONSTANTS= {parameters.lattice.a:0.3f} {parameters.lattice.b:0.3f} {parameters.lattice.c:0.3f} "
            f"{parameters.lattice.alpha:0.3f} {parameters.lattice.beta:0.3f} {parameters.lattice.gamma:0.3f}\n"
        )

        # reindexing matrix
        if parameters.reindex is not None:
            dataset_text += "REIDX= {} {} {} {} {} {} {} {} {} {} {} {}\n".format(*parameters.reindex)

    # reference data
    if parameters.reference is not None:
        dataset_text += f"REFERENCE_DATA_SET=  {parameters.reference}\n"

    beamline_text = (
        "!----------------- Beamline parameters\n"
        f"DETECTOR= {detector_type}\n"
        f"NX={experiment.detector_size.x}   NY= {experiment.detector_size.y}\n"
        f"QX={experiment.pixel_size.x:7.5f} QY={experiment.pixel_size.y:7.5f}\n"
        f"ORGX={experiment.detector_origin.x:5.0f}  ORGY={experiment.detector_origin.y:5.0f}\n"
        f"SENSOR_THICKNESS= {experiment.sensor_thickness:0.3f}\n"
        f"OVERLOAD= {experiment.cutoff_value}\n"
        f"STRONG_PIXEL= {parameters.strong_sigma:5.0f}\n"
        "TRUSTED_REGION=0.00 1.2\n"
        "TEST_RESOLUTION_RANGE= 50.0 1.0\n"
        "TOTAL_SPINDLE_ROTATION_RANGES= 90 360 30\n"
        "STARTING_ANGLES_OF_SPINDLE_ROTATION= 0 180 15\n"
        "VALUE_RANGE_FOR_TRUSTED_DETECTOR_PIXELS= 6000 30000\n"
        "INCLUDE_RESOLUTION_RANGE=50.0 0.0\n"
        "ROTATION_AXIS= 1.0 0.0 0.0\n"
        "INCIDENT_BEAM_DIRECTION=0.0 0.0 1.0\n"
        "FRACTION_OF_POLARIZATION=0.99\n"
        "POLARIZATION_PLANE_NORMAL= 0.0 1.0 0.0\n"
        "DIRECTION_OF_DETECTOR_X-AXIS= 1.000 0.000 0.000\n"
        f"DIRECTION_OF_DETECTOR_Y-AXIS= {detector_y_axis[0]:0.3f} {detector_y_axis[1]:0.3f} {detector_y_axis[2]:0.3f}\n"
    )

    extra_text = "!----------------- Extra parameters\n"
    if 'PILATUS' in detector_name:
        extra_text += "NUMBER_OF_PROFILE_GRID_POINTS_ALONG_ALPHA/BETA= 13\n"
    if parameters.min_spot_separation is not None:
        extra_text += f'SEPMIN= {parameters.min_spot_separation}\n'
    if parameters.min_spot_size is not None:
        extra_text += f'MINIMUM_NUMBER_OF_PIXELS_IN_A_SPOT= {parameters.min_spot_size}\n'
    if parameters.cluster_radius is not None:
        extra_text += f'CLUSTER_RADIUS= {parameters.cluster_radius}\n'
    if parameters.strict_absorption:
        extra_text += 'STRICT_ABSORPTION_CORRECTION= TRUE\n'
    if parameters.refine_index:
        refine_flags = ' '.join(parameters.refine_index)
        extra_text += f'REFINE(IDXREF)= {refine_flags}\n'
    if parameters.refine_integrate:
        refine_flags = ' '.join(parameters.refine_integrate)
        extra_text += f'REFINE(INTEGRATE)= {refine_flags}\n'

    if parameters.fixed_scale_factors:
        extra_text += f'DATA_RANGE_FIXED_SCALE_FACTOR= {parameters.data_range[0]} {parameters.data_range[1]} 1.0\n'

    if parameters.max_profile_error:
        extra_text += f'MAXIMUM_ERROR_OF_SPOT_POSITION= {parameters.max_profile_error[0]}\n'
        extra_text += f'MAXIMUM_ERROR_OF_SPINDLE_POSITION= {parameters.max_profile_error[1]}\n'

    with open('XDS.INP', 'w') as outfile:
        outfile.write(job_text)
        outfile.write(dataset_text)
        outfile.write(beamline_text)
        outfile.write(extra_text)

